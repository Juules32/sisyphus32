use crate::{bit_move::{BitMove, ScoringMove}, butterfly_heuristic::ButterflyHeuristic, color::Color, killer_moves::KillerMoves, piece::PieceType, position::Position, square::Square, transposition_table::{TTNodeType, TranspositionTable}, zobrist::ZobristKey};

const PIECE_SCORES: [i16; 13] = [100, 300, 320, 500, 900, 10000, 100, 300, 320, 500, 900, 10000, 0];

const WP_POSITION_SCORES: [i16; 64] = [
    190, 190, 190, 190, 190, 190, 190, 190, 
    130, 130, 130, 140, 140, 130, 130, 130,
    120, 120, 120, 130, 130, 130, 120, 120,
    110, 110, 110, 120, 120, 110, 110, 110,
    105, 105, 110, 120, 120, 105, 105, 105,
    100, 100, 100, 105, 105, 100, 100, 100, 
    100, 100, 100, 90,  90,  100, 100, 100,
    100, 100, 100, 100, 100, 100, 100, 100
];

const WN_POSITION_SCORES: [i16; 64] = [
    295, 300, 300, 300, 300, 300, 300, 295, 
    295, 300, 300, 310, 310, 300, 300, 295,
    295, 305, 320, 320, 320, 320, 305, 295,
    295, 310, 320, 330, 330, 320, 310, 295,
    295, 310, 320, 330, 330, 320, 310, 295,
    295, 305, 320, 310, 310, 320, 305, 295,
    295, 300, 300, 300, 300, 300, 300, 295,
    295, 290, 300, 300, 300, 300, 290, 295
];

const WB_POSITION_SCORES: [i16; 64] = [
    320, 320, 320, 320, 320, 320, 320, 320, 
    320, 320, 320, 320, 320, 320, 320, 320,
    320, 320, 320, 330, 330, 320, 320, 320,
    320, 320, 330, 340, 340, 330, 320, 320,
    320, 320, 330, 340, 340, 330, 320, 320, 
    320, 330, 320, 320, 320, 320, 330, 320,
    320, 350, 320, 320, 320, 320, 350, 320,
    320, 320, 310, 320, 320, 310, 320, 320
];

const WR_POSITION_SCORES: [i16; 64] = [
    550, 550, 550, 550, 550, 550, 550, 550, 
    550, 550, 550, 550, 550, 550, 550, 550,
    500, 500, 510, 520, 520, 510, 500, 500,
    500, 500, 510, 520, 520, 510, 500, 500,
    500, 500, 510, 520, 520, 510, 500, 500,
    500, 500, 510, 520, 520, 510, 500, 500,
    500, 500, 510, 520, 520, 510, 500, 500,
    500, 500, 500, 520, 520, 500, 500, 500
];

const WQ_POSITION_SCORES: [i16; 64] = [
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000
];

const WK_POSITION_SCORES: [i16; 64] = [
    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 
    10000, 10000, 10005, 10005, 10005, 10005, 10000, 10000,
    10000, 10005, 10005, 10010, 10010, 10005, 10005, 10000,
    10000, 10005, 10010, 10020, 10020, 10010, 10005, 10000,
    10000, 10005, 10010, 10020, 10020, 10010, 10005, 10000,
    10000, 10000, 10005, 10010, 10010, 10005, 10000, 10000,
    10000, 10005, 10005, 9995, 9995, 10000, 10005, 10000,
    10000, 10000, 10005, 10000, 9985, 10000, 10010, 10000
];


const BP_POSITION_SCORES: [i16; 64] = [
    -100, -100, -100, -100, -100, -100, -100, -100, 
    -100, -100, -100,  -90,  -90, -100, -100, -100,
    -100, -100, -100, -105, -105, -100, -100, -100,
    -105, -105, -110, -120, -120, -105, -105, -105,
    -110, -110, -110, -120, -120, -110, -110, -110,
    -120, -120, -120, -130, -130, -130, -120, -120,
    -130, -130, -130, -140, -140, -130, -130, -130,
    -190, -190, -190, -190, -190, -190, -190, -190
];

const BN_POSITION_SCORES: [i16; 64] = [
    -295, -290, -300, -300, -300, -300, -290, -295, 
    -295, -300, -300, -300, -300, -300, -300, -295,
    -295, -305, -320, -310, -310, -320, -305, -295,
    -295, -310, -320, -330, -330, -320, -310, -295,
    -295, -310, -320, -330, -330, -320, -310, -295,
    -295, -305, -320, -320, -320, -320, -305, -295,
    -295, -300, -300, -310, -310, -300, -300, -295,
    -295, -300, -300, -300, -300, -300, -300, -295
];

const BB_POSITION_SCORES: [i16; 64] = [
    -320, -320, -310, -320, -320, -310, -320, -320, 
    -320, -350, -320, -320, -320, -320, -350, -320,
    -320, -330, -320, -320, -320, -320, -330, -320,
    -320, -320, -330, -340, -340, -330, -320, -320,
    -320, -320, -330, -340, -340, -330, -320, -320,
    -320, -320, -320, -330, -330, -320, -320, -320,
    -320, -320, -320, -320, -320, -320, -320, -320,
    -320, -320, -320, -320, -320, -320, -320, -320
];

const BR_POSITION_SCORES: [i16; 64] = [
    -500, -500, -500, -520, -520, -500, -500, -500, 
    -500, -500, -510, -520, -520, -510, -500, -500,
    -500, -500, -510, -520, -520, -510, -500, -500,
    -500, -500, -510, -520, -520, -510, -500, -500,
    -500, -500, -510, -520, -520, -510, -500, -500,
    -500, -500, -510, -520, -520, -510, -500, -500, 
    -550, -550, -550, -550, -550, -550, -550, -550,
    -550, -550, -550, -550, -550, -550, -550, -550
];

const BQ_POSITION_SCORES: [i16; 64] = [
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
    -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000
];

const BK_POSITION_SCORES: [i16; 64] = [
    -10000, -10000, -10005, -10000, -9985, -10000, -10010, -10000, 
    -10000, -10005, -10005, -9995, -9995, -10000, -10005, -10000,
    -10000, -10000, -10005, -10010, -10010, -10005, -10000, -10000,
    -10000, -10005, -10010, -10020, -10020, -10010, -10005, -10000,
    -10000, -10005, -10010, -10020, -10020, -10010, -10005, -10000,
    -10000, -10005, -10005, -10010, -10010, -10005, -10005, -10000,
    -10000, -10000, -10005, -10005, -10005, -10005, -10000, -10000,
    -10000, -10000, -10000, -10000, -10000, -10000, -10000, -10000
];

const PIECE_POSITION_SCORES: [&[i16; 64]; 12] = [
    &WP_POSITION_SCORES, &WN_POSITION_SCORES, &WB_POSITION_SCORES, &WR_POSITION_SCORES, &WQ_POSITION_SCORES, &WK_POSITION_SCORES,
    &BP_POSITION_SCORES, &BN_POSITION_SCORES, &BB_POSITION_SCORES, &BR_POSITION_SCORES, &BQ_POSITION_SCORES, &BK_POSITION_SCORES,
];

// Most valuable victim - least valuable attacker [attacker][victim]
const MVV_LVA: [[i16; 12]; 12] = [
    [105, 205, 305, 405, 505, 605, 105, 205, 305, 405, 505, 605],
    [104, 204, 304, 404, 504, 604, 104, 204, 304, 404, 504, 604],
    [103, 203, 303, 403, 503, 603, 103, 203, 303, 403, 503, 603],
    [102, 202, 302, 402, 502, 602, 102, 202, 302, 402, 502, 602],
    [101, 201, 301, 401, 501, 601, 101, 201, 301, 401, 501, 601],
    [100, 200, 300, 400, 500, 600, 100, 200, 300, 400, 500, 600],
    [105, 205, 305, 405, 505, 605, 105, 205, 305, 405, 505, 605],
    [104, 204, 304, 404, 504, 604, 104, 204, 304, 404, 504, 604],
    [103, 203, 303, 403, 503, 603, 103, 203, 303, 403, 503, 603],
    [102, 202, 302, 402, 502, 602, 102, 202, 302, 402, 502, 602],
    [101, 201, 301, 401, 501, 601, 101, 201, 301, 401, 501, 601],
    [100, 200, 300, 400, 500, 600, 100, 200, 300, 400, 500, 600],
];

pub struct EvalPosition { }

impl EvalPosition {
    #[inline(always)]
    fn basic(position: &Position) -> ScoringMove {
        ScoringMove::blank(Square::ALL_SQUARES.iter().fold(0, |acc, &sq| {
            acc + PIECE_SCORES[position.get_piece(sq) as usize]
        }) * match position.side {
            Color::White => 1,
            Color::Black => -1
        })
    }

    #[inline(always)]
    fn piece_positions(position: &Position) -> ScoringMove {
        ScoringMove::blank(Square::ALL_SQUARES.iter().fold(0, |acc, &sq| {
            match position.get_piece(sq) {
                PieceType::None => acc,
                piece => acc + PIECE_POSITION_SCORES[piece as usize][sq] 
            }
        }) * match position.side {
            Color::White => 1,
            Color::Black => -1
        })
    }

    #[inline(always)]
    pub fn eval(position: &Position) -> ScoringMove {
        #[cfg(feature = "eval_basic")]
        return EvalPosition::basic(position);

        #[cfg(feature = "eval_piece_positions")]
        return EvalPosition::piece_positions(position);
    }

    #[inline(always)]
    pub fn eval_with_history(position: &Position, zobrist_hash_history: &Vec<ZobristKey>) -> ScoringMove {
        if zobrist_hash_history.contains(&position.zobrist_key) {
            return ScoringMove::blank(0);
        }

        return Self::eval(position)
    }
}

pub struct EvalMove { }

impl EvalMove {
    #[inline(always)]
    pub fn eval(position: &Position, bit_move: BitMove) -> i16 {
        let mut score = if position.get_piece(bit_move.target()) == PieceType::None {
            0
        } else {
            MVV_LVA[position.get_piece(bit_move.source()) as usize][position.get_piece(bit_move.target()) as usize]
        };

        #[cfg(feature = "eval_transposition_table")]
        {
            if let Some(entry) = TranspositionTable::probe(position.zobrist_key) {
                if entry.best_move.bit_move == bit_move {
                    match entry.flag {
                        TTNodeType::Exact => score += 50,
                        TTNodeType::LowerBound => score += 30,
                        TTNodeType::UpperBound => score += 20,
                    }
                }
            }
        }

        #[cfg(feature = "killer_moves")]
        {
            if KillerMoves::get_primary(position.ply) == bit_move {
                score += 100;
            } else if KillerMoves::get_secondary(position.ply) == bit_move {
                score += 50;
            }
        }

        #[cfg(feature = "butterfly_heuristic")]
        {
            score += ButterflyHeuristic::get(position.side, bit_move.source(), bit_move.target());
        }
        score
    }
}
